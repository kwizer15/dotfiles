snippet c 
	<?php

	declare(strict_types=1);
	
	namespace ${1:`substitute(substitute(expand("%:h"), '\v^\w+\/(\u)', '\1', ''), '\/', '\\\', 'g')`};
	
	final class ${2:`Filename()`}
	{
		${0:${VISUAL}}
	}
snippet i
	<?php

	declare(strict_types=1);
	
	namespace ${1:`substitute(substitute(expand("%:h"), '\v^\w+\/(\u)', '\1', ''), '\/', '\\\', 'g')`};
	
	interface ${1:`Filename()`}
	{
		${0:${VISUAL}}
	}
snippet dent
	<?php

	declare(strict_types=1);
	
	namespace ${1:`substitute(substitute(expand("%:h"), '\v^\w+\/(\u)', '\1', ''), '\/', '\\\', 'g')`};

	use Doctrine\ORM\Mapping as ORM;

	/**
	 * @ORM/Entity
	 */	
	final class ${2:`Filename()`}
	{
		${0:${VISUAL}}
	}
snippet denta
	<?php

	declare(strict_types=1);
	
	namespace ${1:`substitute(substitute(expand("%:h"), '\v^\w+\/(\u)', '\1', ''), '\/', '\\\', 'g')`};

	use Doctrine\ORM\Mapping as ORM;

	#[ORM/Entity]
	final class ${2:`Filename()`}
	{
		${0:${VISUAL}}
	}
snippet dep
	/**
	 * @ORM\Column(${4})
	 */
	private ${1:string} $${2:foo};

	${0:${VISUAL}}

	public function get${3:Foo}(): ${1:string}
	{
		return $this->${2:foo};
	}

	public function set${3:Foo}(${1:string} $${2:foo}): self
	{
		$this->${2:foo} = $${2:foo};

		return $this;
	}
snippet depa
	#[ORM\Column${6}]
	private ${1:string} $${2:foo};

	${0:${VISUAL}}

	public function get${3:$2}(): ${4:$1}
	{
		return $this->${5:$2};
	}

	public function set${3:Foo}(${1:string} $${2:foo}): self
	{
		$this->${2:foo} = $${2:foo};

		return $this;
	}
snippet t.
	\$this->
# method
snippet m
	${1:public} function ${2:foo}(): ${3:void}
	{
		${0:${VISUAL}}
	}
snippet sm "PHP Class Setter"
	/**
	 * @param ${2:string} $$1 ${3:description}
	 *
	 * @return ${4:`Filename()`}
	 */
	${5:public} function set${6:$1}(${7:$2 }$$1)
	{
		$this->${8:$1} = $$1;

		return $this;
	}
snippet gm "PHP Class Getter Setter"
	/**
	 * Gets the value of ${1:foo}
	 *
	 * @return ${2:string}
	 */
	${3:public} function get${4:$1}()
	{
		return $this->${5:$1};
	}
#setter
snippet $s
	${1:$foo}->set${2:Bar}(${0});
#getter
snippet $g
	${1:$foo}->get${0:Bar}();
# Tertiary conditional
snippet =?:
	$${1:foo} = ${2:true} ? ${3:a} : ${0};
snippet ?:
	${1:true} ? ${2:a} : ${0}
snippet t "$retVal = (condition) ? a : b"
	$${1:retVal} = ($2) ? ${3:a} : ${4:b};
# Predefined variables
# the following are old ones
snippet vend
	require dirname(__DIR__).'/vendor/autoload.php';
# Start Docblock
snippet /**
	/**
	 * ${0}
	 */
# Constant Definition - post doc
snippet const
	${1:private} const ${2} = ${0:VISUAL};
# Constant Definition
snippet inheritdoc "@inheritdoc docblock"
	/**
	 * {@inheritdoc}
	 */
snippet wh "while (condition) { ... }"
	while ($1) {
		${0:${VISUAL}}
	}
snippet do "do { ... } while (condition)"
	do {
		${0:${VISUAL}}
	} while (${1});
snippet if "if (condition) { ... }"
	if (${1}) {
		${0:${VISUAL}}
	}
snippet ifn "if (false === condition) { ... }"
	if (false === ${1}) {
		${0:${VISUAL}}
	}
snippet ife "if (cond) { ... } else { ... }"
	if (${1}) {
		${0:${VISUAL}}
	} else {
		${2}
	}
snippet el "else { ... }"
	else {
		${0:${VISUAL}}
	}
snippet eif "elseif(condition) { ... }"
	elseif (${1}) {
		${0:${VISUAL}}
	}
snippet switch "switch($var) { case 'xyz': ... default: .... }"
	switch ($${1:variable}) {
		case '${2:value}':
			${3}
			break;
		${0}
		default:
			${4}
			break;
	}
snippet case "case 'value': ... break"
	case '${1:value}':
		${0:${VISUAL}}
		break;
snippet for "for ($i = 0; $i < $count; $i++) { ... }"
	for ($${2:i} = 0; $$2 < ${1:count}; $$2${3:++}) {
		${0:${VISUAL}}
	}
snippet foreach "foreach ($var as $value) { .. }"
	foreach ($${1:variable} as $${2:value}) {
		${0:${VISUAL}}
	}
snippet foreachk "foreach ($var as $key => $value) { .. }"
	foreach ($${1:variable} as $${2:key} => $${3:value}) {
		${0:${VISUAL}}
	}
snippet array "$... = ['' => ]"
	$${1:arrayName} = ['${2}' => ${3}];
snippet try "try { ... } catch (Exception $e) { ... }"
	try {
		${0:${VISUAL}}
	} catch (${1:Exception} $e) {
	}
# lambda with closure
snippet lambda
	${1:static }function (${2:args}) use (${3:&$x, $y /*put vars in scope (closure) */}) {
		${0}
	};
snippet dd
	dd(${0:${VISUAL}});
snippet rett
	return true;
snippet retf
	return false;
snippet am
	$${1:foo} = array_map(function($${2:v}) {
		${0}
		return $$2;
	}, $$1);
snippet CSVWriter
	<?php
	
	class CSVWriter 
	{
		public function __construct($file_or_handle, $sep = "\t", $quot = '"')
		{
			$args = func_get_args();
			$mode = isset($opts['mode']) ? $opts['mode'] : 'w';
	
			$this->f =
				is_string($file_or_handle)
				? fopen($file_or_handle, $mode)
				: $file_or_handle;
	
			$this->fputcsv_args = [$this->f, null, $sep, $quot];
	
			if (!$this->f) throw new Exception('bad file descriptor');
		}
	
		public function write($row): void
		{
			$this->fputcsv_args[1] =& $row;
			call_user_func_array('fputcsv', $this->fputcsv_args);
		}
	
		public function close(): void
		{
			if (!is_null($this->f)) {
				fclose($this->f);
			}
			$this->f = null;
		}
	
		public function __destruct(): void
		{
			$this->close();
		}
	
	}
snippet CSVIterator
	
	// http://snipplr.com/view.php?codeview&id=1986 // modified
	class CSVIterator implements Iterator
	{	
		private $f;
		private $curr;
		private $rowCounter;
	
		 /* opts keys:
			* row_size
			* escape
			* enclosure
			* delimiter
			*/
		public function __construct( $file_or_handle, $opts = [4096, ','] )
		{
			$d = function($n) use(&$opts){ return isset($opts[$n]) ? $opts[$n] : false; };
	
			$this->combine = $d('combine');
			$this->headers = $d('headers');
			$this->headerCheckFunction = $d('header_check_function');
	
			$this->f =
				is_string($file_or_handle)
				? fopen( $file_or_handle, 'r' )
				: $file_or_handle;
			if (!$this->f) throw new Exception('bad file descriptor');
			$this->fgetcsv_args = [
					$this->f,
					isset($opts['row_size']) ? $opts['row_size'] : 4096,
					isset($opts['delimiter']) ? $opts['delimiter'] : ',',
					isset($opts['enclosure']) ? $opts['enclosure'] : '"',
					isset($opts['escape']) ? $opts['escape'] : '\\',
			];
			$this->start();
		}
	
		protected function readRow(){
			$this->curr = call_user_func_array('fgetcsv', $this->fgetcsv_args );
			$this->rowCounter++;
			if ($this->rowCounter == 1){
				$this->processHeader();
			} elseif ($this->curr) {
				$this->processRow();
			}
		}
	
		public function processHeader(){
			if ($this->headers || $this->combine){
				$this->header = $this->curr;
				if ($this->headerCheckFunction){
					$f = $this->headerCheckFunction;
					$f($this->header);
				}
				$this->readRow();
			}
		}
	
		public function processRow(){
			if ($this->combine)
				$this->curr = array_combine($this->header, $this->curr);
		}
	
		public function start(){
			$this->rowCounter = 0;
			rewind( $this->f );
			$this->readRow();
		}
	
		public function rewind()
		{
			$this->start();
		}
	
		public function current()
		{
			$curr = $this->curr;
			$this->readRow();
			return $curr;
		}
	
		public function key()
		{
			return $this->rowCounter;
		}
	
		public function next()
		{
			return $this->curr;
		}
	
		public function valid(){
			if( !$this->next() )
			{
				fclose( $this->f );
				return FALSE;
			}
			return TRUE;
		}
	
	} // end class
# phpunit
snippet testcase
	<?php

	declare(strict_types=1);
	
	namespace ${1:`substitute(substitute(expand("%:h"), '\v^\w+\/(\u)', '\1', ''), '\/', '\\\', 'g')`};

	use PHPUnit\\Framework\\TestCase;
	
	final class ${2:`Filename()`} extends TestCase
	{
		public function test${1}(): void
		{
			${0:${VISUAL}}
		}
	}
snippet ase "$this->assertEquals($a, $b)"
	$this->assertEquals(${1:$expected}, ${2:$actual});
snippet asne "$this->assertNotEquals($a, $b)"
	$this->assertNotEquals(${1:$expected}, ${2:$actual});
snippet asf "$this->assertFalse($a)"
	$this->assertFalse(${1});
snippet ast "$this->assertTrue($a)"
	$this->assertTrue(${1});
snippet asfex "$this->assertFileExists('path/to/file')"
	$this->assertFileExists(${1:'path/to/file'});
snippet asfnex "$this->assertFileNotExists('path/to/file')"
	$this->assertFileNotExists(${1:'path/to/file'});
snippet ascon "$this->assertContains($needle, $haystack)"
	$this->assertContains(${1:$needle}, ${2:$haystack});
snippet asncon "$this->assertNotContains($needle, $haystack)"
	$this->assertNotContains(${1:$needle}, ${2:$haystack});
snippet ascono "$this->assertContainsOnly($needle, $haystack)"
	$this->assertContainsOnly(${1:$needle}, ${2:$haystack});
snippet asconoi "$this->assertContainsOnlyInstancesOf(Example::class, $haystack)"
	$this->assertContainsOnlyInstancesOf(${1:Example}::class, ${2:$haystack});
snippet ashk "$this->assertArrayHasKey($key, $array)"
	$this->assertArrayHasKey(${1:$key}, ${2:$array});
snippet asnhk "$this->assertArrayNotHasKey($key, $array)"
	this->assertArrayNotHasKey(${1:$key}, ${2:$array});
snippet ascha "$this->assertClassHasAttribute($name, Example::class)"
	$this->assertClassHasAttribute(${1:$attributeName}, ${2:Example}::class);
snippet asi "$this->assertInstanceOf(Example::class, $actual)"
	$this->assertInstanceOf(${1:Example}::class, ${2:$actual});
snippet asit "$this->assertInternalType('string', $actual)"
	$this->assertInternalType(${1:'string'}, ${2:actual});
snippet asco "$this->assertCount($count, $haystack)"
	$this->assertCount(${1:$expectedCount}, ${2:$haystack});
snippet asnco "$this->assertNotCount($count, $haystack)"
	$this->assertNotCount(${1:$count}, ${2:$haystack});
snippet assub "$this->assertArraySubset($subset, $array)"
	$this->assertArraySubset(${1:$subset}, ${2:$array});
snippet asnu "$this->assertNull($a)"
	$this->assertNull(${1});
snippet asnnu "$this->assertNotNull($a)"
	$this->assertNotNull(${1});
snippet test "public function testXYZ() { ... }"
	public function test${1}()
	{
		${0:${VISUAL}}
	}
snippet setup "protected function setUp() { ... }"
	protected function setUp()
	{
		${0:${VISUAL}}
	}
snippet teardown "protected function tearDown() { ... }"
	protected function tearDown()
	{
		${0:${VISUAL}}
	}
snippet proph "$observer = $this->prophesize(SomeClass::class);"
	$${1:observer} = $this->prophesize(${2:SomeClass}::class);
snippet mock "$mock = $this->createMock(SomeClass::class);"
	$${1:mock} = $this->createMock(${2:SomeClass}::class);
snippet exp "phpunit expects"
	expects($this->${1:once}())
		->method('${2}')
		->with(${3})
		->willReturn(${4});
snippet testcmt "phpunit comment with group"
	/**
	* @group ${1}
	*/
snippet fail "$this->fail()"
	$this->fail(${1});
snippet marki "$this->markTestIncomplete()"
	$this->markTestIncomplete(${1});
snippet marks "$this->markTestSkipped()"
	$this->markTestSkipped(${1});
# end of phpunit snippets
snippet te "throw new Exception()"
	throw new ${1:Exception}("${2:Error Processing Request}");


snippet csfix
	<?php

	$finder = PhpCsFixer\Finder::create()
		->exclude('vendor')
		->exclude('var')
		->notPath('src/Symfony/Component/Translation/Tests/fixtures/resources.php')
		->in(__DIR__)
	;

	$config = new PhpCsFixer\Config();
	$config->setRiskyAllowed(true)
		->setRules([
			'@Symfony' => true,
			'array_syntax' => ['syntax' => 'short'],
			'dir_constant' => true,
			'phpdoc_align' => false,
			'phpdoc_no_package' => true,
			'no_superfluous_phpdoc_tags' => true,
			'ordered_imports' => true,
			'single_line_throw' => false,
			'function_typehint_space' => false,
			'phpdoc_trim_consecutive_blank_line_separation' => false,
		])
		->setFinder($finder)
	;

	return $config;
